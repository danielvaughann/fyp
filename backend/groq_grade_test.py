QUESTIONS = [
    {
        "id": 1,
        "topic": "Data Structures",
        "difficulty": "Junior",
        "question": "What is a data structure and how does it relate to data organization and retrieval?",
        "reference_answer": "A data structure is how data is organized (stored) and manipulated for retrieval and access. It defines the way different sets of data relate to one another, establishing relationships and forming algorithms for efficient memory usage.",
        "keywords": ["organize data", "operations", "efficient access", "time space tradeoff", "array"],
    },
    {
        "id": 2,
        "topic": "Data Structures",
        "question": "What is a linked list and in what scenarios would you use it over an array?",
        "reference_answer": "A linked list is a linear data structure where elements are not stored in adjacent memory locations but are linked using pointers to form a chain. Use linked lists when you have an unknown number of objects, need constant time insertions/deletions, don't need random access, or want to insert items in the middle of the list.",
        "keywords": ["node", "pointer", "non contiguous memory", "O(1) insert/delete", "no random access"],
    },
    {
        "id": 3,
        "topic": "Data Structures",
        "question": "What are the advantages of a linked list over an array?",
        "reference_answer": "Linked lists offer easier insertion and deletion (only updating pointers), work as dynamic data structures (grow and shrink at runtime), have no memory wastage (memory allocated only when needed), and are more easily implemented using data structures like stacks and queues compared to arrays.",
        "keywords": ["O(1) insertion", "O(1) deletion", "dynamic size", "pointer updates", "cache locality tradeoff"],
    },
    {
        "id": 4,
        "topic": "Data Structures",
        "question": "What is a doubly linked list and provide an example of its application.",
        "reference_answer": "A doubly linked list is a complex type of linked list in which a node has two links—one connecting to the next node and another to the previous node. This allows traversal in both directions. Examples include music playlists with next/previous buttons, browser history, and undo/redo functionality.",
        "keywords": ["prev pointer", "next pointer", "bidirectional traversal", "O(1) delete with node", "browser history"],
    },
    {
        "id": 5,
        "topic": "Data Structures",
        "question": "What is a deque and how does it differ from a regular queue?",
        "reference_answer": "A deque (double ended queue) is a data structure where elements can be inserted or deleted at both ends (FRONT and REAR), whereas a regular queue only allows insertion at the rear and deletion at the front, following strict first in first out  ordering.",
        "keywords": ["double ended", "insert/remove both ends", "front and rear", "not strict first in first out ", "sliding window"],
    },
    {
        "id": 6,
        "topic": "Data Structures",
        "question": "What is the difference between a binary tree and a binary search tree?",
        "reference_answer": "A binary tree is a tree structure where each node has at most two children (left and right). A binary search tree is a specific type of binary tree where the left child is always less than the parent, and the right child is always greater, enabling efficient searching and retrieval.",
        "keywords": ["two children", "left < root < right", "in order sorted", "search O(log n)", "not inherently ordered"],
    },
    {
        "id": 7,
        "topic": "Data Structures",
        "question": "What is a hash table and what causes collisions?",
        "reference_answer": "A hash table is a data structure that implements an associative array—a structure that maps keys to values using a hash function. Collisions occur when the hash function maps two different keys to the same bucket or location in the hash table.",
        "keywords": ["key value mapping", "hash function", "bucket/index", "collision", "same bucket different keys"],
    },
    {
        "id": 8,
        "topic": "Data Structures",
        "question": "How do you resolve hash table collisions and what are the trade offs?",
        "reference_answer": "Common collision resolution techniques include chaining (storing multiple values in a linked list at each bucket) and open addressing (finding another empty bucket using probing strategies like linear, quadratic, or double hashing). Chaining is simpler but uses extra space; open addressing is more cache friendly but requires careful probe sequence design.",
        "keywords": ["chaining", "open addressing", "linear/quadratic probing", "load factor", "space vs cache tradeoff"],
    },
    {
        "id": 9,
        "topic": "Data Structures",
        "question": "What is a stack and explain the last in first out principle.",
        "reference_answer": "A stack is an abstract data type that specifies a linear data structure where you can only take the top item off the stack to remove things. Insertion (push) and deletion (pop) take place only at one end called the top, following last in first out (Last In First Out) principle—the last item inserted is the first to be removed.",
        "keywords": ["top", "last in first out", "push", "pop", "call stack"],
    },
    {
        "id": 10,
        "topic": "Stacks & Queues",
        "question": "What are the three fundamental operations that can be performed on a stack?",
        "reference_answer": "The three operations are PUSH (inserts a new element at the top), POP (removes the topmost element), and PEEK (returns the value of the topmost element without removing it).",
        "keywords": ["push", "pop", "peek", "isEmpty", "overflow/underflow"],
    },
    {
        "id": 11,
        "topic": "Stacks & Queues",
        "question": "What is a queue and explain the first in first out  principle.",
        "reference_answer": "A queue is an abstract data type that specifies a linear data structure or ordered list using the First In First Out (first in first out ) operation. Insert operations occur at the REAR, and delete operations occur at the FRONT—the first element inserted is the first to be removed.",
        "keywords": ["first in first out ", "enqueue", "dequeue", "front/rear", "task queue"],
    },
    {
        "id": 12,
        "topic": "Stacks & Queues",
        "question": "What is the difference between a PUSH and a POP operation on a stack?",
        "reference_answer": "PUSH is used to add an item to a stack and takes two arguments (stack name and value), while POP is used to remove an item and takes only the stack name. PUSH causes a stack overflow error if the stack is full; POP causes a stack underflow error if the stack is empty.",
        "keywords": ["push add", "pop remove", "overflow", "underflow", "top pointer"],
    },
    {
        "id": 13,
        "topic": "Stacks & Queues",
        "question": "What are the applications of queue data structures?",
        "reference_answer": "Queues are used as waiting lists for shared resources (printers, CPU scheduling, call centers), in asynchronous data transfer (pipes, file IO, sockets), as buffers in media players (MP3, CD players), and to maintain playlists in media players.",
        "keywords": ["buffer", "CPU scheduling", "producer consumer", "BFS", "I/O queue"],
    },
    {
        "id": 14,
        "topic": "Stacks & Queues",
        "question": "What is a postfix expression and how does it relate to stack operations?",
        "reference_answer": "A postfix expression comprises operators and operands with the operator coming after the operands (example: A B C * + instead of A + B * C). Stacks are used to evaluate postfix expressions efficiently by pushing operands and applying operators when encountered.",
        "keywords": ["postfix (RPN)", "operator after operands", "stack evaluation", "push operands", "pop apply operator"],
    },
    {
        "id": 15,
        "topic": "Stacks & Queues",
        "question": "What is a priority queue and how does it differ from a regular queue?",
        "reference_answer": "A priority queue is a queue where each element has an associated priority, and elements with higher priority are dequeued before elements with lower priority, unlike a regular queue where elements are strictly first in first out .",
        "keywords": ["priority key", "heap", "dequeue highest", "not first in first out ", "job scheduling"],
    },
    {
        "id": 16,
        "topic": "Stacks & Queues",
        "question": "What are dynamic data structures and provide examples.",
        "reference_answer": "Dynamic data structures are collections of data in memory that expand and contract to grow or shrink in size as a program runs. This enables programmers to control exactly how much memory will be utilized. Examples include dynamic arrays, linked lists, stacks, queues, and heaps.",
        "keywords": ["heap allocation", "grow/shrink", "resize", "memory management", "linked list"],
    },
    {
        "id": 17,
        "topic": "Trees & Graphs",
        "question": "Define the graph data structure and explain directed versus undirected graphs.",
        "reference_answer": "A graph is a non linear data structure consisting of vertices (nodes) connected by edges (arcs) that enable data storage or retrieval. Edges may be directed (pointing from one vertex to another, like one way streets) or undirected (bidirectional connections, like friendships).",
        "keywords": ["vertex/node", "edge", "adjacency list", "directed arrow", "undirected bidirectional"],
    },
    {
        "id": 18,
        "topic": "Trees & Graphs",
        "question": "What are the applications of graph data structures?",
        "reference_answer": "Graphs are used in transport networks (stations as vertices, routes as edges), utility grids (power/water with connection points as vertices), social networks (nodes as people, edges as relationships), recommendation systems, GPS navigation, and neural networks (neurons as vertices, synapses as edges).",
        "keywords": ["routing", "social network", "recommendation", "dependency graph", "GPS navigation"],
    },
    {
        "id": 19,
        "topic": "Trees & Graphs",
        "question": "Describe the types of trees used in computer science.",
        "reference_answer": "Main tree types include: General Tree (unlimited offspring per node), Binary Tree (each parent has at most two children), Binary Search Tree (left child less than parent, right child greater), AVL Tree (self balancing), Red Black Tree (auto balancing using color properties), and N ary Tree (maximum N children per node.",
        "keywords": ["BST", "AVL balancing", "red black properties", "n ary tree", "search vs balance tradeoff"],
    },
    {
        "id": 20,
        "topic": "Trees & Graphs",
        "question": "What is a binary tree and what information does each node contain?",
        "reference_answer": "A binary tree is a tree data structure where each node has at most two offspring called left and right children. Each node contains: data (the actual value), a pointer to the left child, and a pointer to the right child.",
        "keywords": ["data value", "left pointer", "right pointer", "two children", "traversal recursion"],
    },
    {
        "id": 21,
        "topic": "Trees & Graphs",
        "question": "How do you find the height of a node in a tree?",
        "reference_answer": "The height of a node equals the number of edges in the longest path from that node to a leaf, where the height of a leaf node is 0 and the height represents the depth of the subtree rooted at that node.",
        "keywords": ["edges count", "longest path", "leaf node", "subtree", "leaf height 0"],
    },
    {
        "id": 22,
        "topic": "Trees & Graphs",
        "question": "What is the difference between depth and height of a tree?",
        "reference_answer": "The depth of a node is the number of edges from the root to that node, while the height of a node is the number of edges from that node to the deepest leaf. The depth of the root is 0, and the height of a leaf is 0.",
        "keywords": ["depth from root", "height to leaf", "edges", "root depth 0", "leaf height 0"],
    },
    {
        "id": 23,
        "topic": "Trees & Graphs",
        "question": "What are breadth first search (BFS) and depth first search (DFS) and how do they differ?",
        "reference_answer": "BFS explores vertices in layers starting from the root, visiting all neighbors at the current depth before moving deeper, using a queue data structure. DFS explores as far as possible along each branch before backtracking, using a stack or recursion. BFS finds shortest paths in unweighted graphs; DFS is useful for topological sorting and cycle detection.",
        "keywords": ["queue", "stack/recursion", "level order", "backtracking", "shortest path unweighted"],
    },
    {
        "id": 24,
        "topic": "Trees & Graphs",
        "question": "What is the difference between a complete binary tree and a full binary tree?",
        "reference_answer": "A full binary tree is one where every node has either 0 or 2 children (no node has just one child). A complete binary tree is one where all levels are completely filled except possibly the last level, which is filled from left to right.",
        "keywords": ["full: 0 or 2 children", "complete: filled left to right", "last level", "heap shape", "structure constraint"],
    },
    {
        "id": 25,
        "topic": "Algorithms & Complexity",
        "question": "What is an algorithm and why do we need to perform algorithm analysis?",
        "reference_answer": "An algorithm is a step by step method of solving a problem or manipulating data. Algorithm analysis provides an estimation of the required resources (time and space) to solve a computational problem, helping us choose the most efficient solution for a given workload.",
        "keywords": ["step by step", "time complexity", "space complexity", "choose efficient", "asymptotic growth"],
    },
    {
        "id": 26,
        "topic": "Algorithms & Complexity",
        "question": "Define Big O notation and provide examples of common complexities.",
        "reference_answer": "Big O notation describes the upper bound of an algorithm's running time as input size grows. Common complexities include O(1) constant time, O(log n) logarithmic, O(n) linear, O(n log n) linearithmic, O(n^2) quadratic, and O(2^n) exponential.",
        "keywords": ["upper bound", "O(1)", "O(log n)", "O(n)", "O(n^2)"],
    },
    {
        "id": 27,
        "topic": "Algorithms & Complexity",
        "question": "What does it mean when running time doubles roughly every time input size doubles?",
        "reference_answer": "This suggests exponential time complexity, typically O(2^n), where the algorithm becomes impractical for even moderately large inputs and each additional input element doubles the computation time.",
        "keywords": ["exponential", "2^n", "doubling input effect", "infeasible growth", "recurrence"],
    },
    {
        "id": 28,
        "topic": "Algorithms & Complexity",
        "question": "What is asymptotic analysis of an algorithm?",
        "reference_answer": "Asymptotic analysis determines an algorithm's running time in mathematical units to establish program limits and run time performance. The purpose is to identify best case, worst case, and average case times for completing a particular operation as input size approaches infinity.",
        "keywords": ["ignore constants", "n  > infinity", "best/average/worst", "input size n", "asymptotic growth"],
    },
    {
        "id": 29,
        "topic": "Algorithms & Complexity",
        "question": "What are asymptotic notations and how do they differ?",
        "reference_answer": "Asymptotic notations represent an algorithm's running time: Big O (Ο) for worst case upper bound, Big Theta (Θ) for both upper and lower bounds when they're equal (tight bound), and Big Omega (Ω) for best case lower bound.",
        "keywords": ["Big O upper", "Theta tight", "Omega lower", "bounds", "case analysis"],
    },
    {
        "id": 30,
        "topic": "Algorithms & Complexity",
        "question": "Which sorting algorithm is generally considered the fastest and why?",
        "reference_answer": "QuickSort is generally considered the fastest for average cases because it performs best for most inputs with O(n log n) average complexity. Advantages include cache efficiency (linear scans and partitions), ability to skip some swaps, and easy adaptation to already sorted inputs.",
        "keywords": ["partition", "average O(n log n)", "in place", "worst O(n^2)", "quicksort"],
    },
    {
        "id": 31,
        "topic": "Algorithms & Complexity",
        "question": "Describe how merge sort works using the divide and conquer approach.",
        "reference_answer": "Merge sort works by dividing the input array into two halves, recursively sorting each half, and then merging the two sorted halves back together. This guarantees O(n log n) time complexity in all cases and is a stable sorting algorithm.",
        "keywords": ["divide and conquer", "split halves", "merge step", "stable", "O(n log n)"],
    },
    {
        "id": 32,
        "topic": "Algorithms & Complexity",
        "question": "Compare the time complexities of common sorting algorithms.",
        "reference_answer": "Bubble Sort: O(n^2) all cases; Selection Sort: O(n^2) all cases; Insertion Sort: O(n) best, O(n^2) average/worst; Merge Sort: O(n log n) all cases; Quick Sort: O(n log n) average, O(n^2) worst; Heap Sort: O(n log n) all cases.",
        "keywords": ["quadratic sorts", "linearithmic sorts", "best vs worst", "quicksort avg", "heap/merge O(n log n)"],
    },
    {
        "id": 33,
        "topic": "Algorithms & Complexity",
        "question": "What is dynamic programming and when should you use it?",
        "reference_answer": "Dynamic programming is an optimization technique that breaks a problem into overlapping subproblems, solves each subproblem once, and stores the results to avoid recomputation. Use it when a problem has optimal substructure and overlapping subproblems.",
        "keywords": ["overlapping subproblems", "optimal substructure", "memoization", "tabulation", "avoid recomputation"],
    },
    {
        "id": 34,
        "topic": "Algorithms & Complexity",
        "question": "What is recursion and what is the base case?",
        "reference_answer": "Recursion is when a function calls itself to solve smaller instances of the same problem. The base case is the condition that stops recursion, preventing infinite loops. Every recursive function must have at least one base case to terminate.",
        "keywords": ["self calls", "base case", "stack frames", "termination", "smaller subproblem"],
    },
    {
        "id": 35,
        "topic": "Sorting & Searching",
        "question": "What is the time complexity of binary search on a sorted array?",
        "reference_answer": "Binary search has a time complexity of O(log n) on a sorted array, where n is the length of the array, making it significantly faster than linear search for large datasets.",
        "keywords": ["sorted", "middle element", "halve search space", "O(log n)", "divide and conquer"],
    },
    {
        "id": 36,
        "topic": "Sorting & Searching",
        "question": "What is the best case and worst case time complexity of linear search?",
        "reference_answer": "Best case time complexity is O(1) when the element is found at the first position. Worst case time complexity is O(n) when the element is at the last position or not present in the array.",
        "keywords": ["sequential scan", "best O(1)", "worst O(n)", "works unsorted", "early exit"],
    },
    {
        "id": 37,
        "topic": "Sorting & Searching",
        "question": "What sorting algorithm should be used when stability is required?",
        "reference_answer": "Merge Sort or Insertion Sort should be used when stability is required (equal elements maintain their relative order from the original array). Quick Sort and Heap Sort are not stable sorting algorithms.",
        "keywords": ["stability property", "preserve relative order", "merge sort", "insertion sort", "records with equal keys"],
    },
    {
        "id": 38,
        "topic": "Sorting & Searching",
        "question": "What is the difference between comparison based and non comparison based sorting algorithms?",
        "reference_answer": "Comparison based algorithms (Quick Sort, Merge Sort, Insertion Sort, Bubble Sort) make decisions based on comparing elements. Non comparison sorting algorithms like Counting Sort, Radix Sort, and Bucket Sort organize data without element comparisons and can achieve better than O(n log n) complexity for specific input types.",
        "keywords": ["comparisons", "Counting sort", "Radix sort", "O(n+k)", "bounded key constraint"],
    },
    {
        "id": 39,
        "topic": "Sorting & Searching",
        "question": "What is the difference between in place and out of place sorting algorithms?",
        "reference_answer": "In place sorting algorithms sort data without requiring additional space proportional to the input size (e.g., Quick Sort, Heap Sort with O(log n) space). Out of place algorithms require additional space for temporary storage (e.g., Merge Sort with O(n) space).",
        "keywords": ["space O(1)", "auxiliary array", "in place", "out of place", "memory vs simplicity tradeoff"],
    },
    {
        "id": 40,
        "topic": "Sorting & Searching",
        "question": "What is binary search and what are its requirements?",
        "reference_answer": "Binary search is an efficient search algorithm that works on sorted arrays by repeatedly dividing the search space in half. It requires the array to be sorted. Time complexity is O(log n), and it's much faster than linear search O(n) for large datasets.",
        "keywords": ["sorted requirement", "random access", "middle compare", "halve", "O(log n)"],
    },
    {
        "id": 41,
        "topic": "Operating Systems",
        "question": "What is a process and what information does the process table store?",
        "reference_answer": "A process is an instance of a program in execution. The process table maintains for each process: process ID, program counter, CPU registers, memory allocation pointers, process state, priority, and other resource information needed by the operating system to manage and schedule processes.",
        "keywords": ["process ID", "PCB/process table", "program counter", "state", "resource info"],
    },
    {
        "id": 42,
        "topic": "Operating Systems",
        "question": "What are the different states of a process and how do they transition?",
        "reference_answer": "Processes can be in running (executing on CPU), ready (waiting for CPU time), or waiting (waiting for I/O or events) states. Transitions occur based on scheduling decisions and I/O events: running→ready (preemption), running→waiting (I/O request), waiting→ready (I/O complete).",
        "keywords": ["ready", "running", "blocked/waiting", "I/O event", "scheduler transition"],
    },
    {
        "id": 43,
        "topic": "Operating Systems",
        "question": "What is a thread and how does it differ from a process?",
        "reference_answer": "A thread is a single sequence stream within a process, also called a lightweight process. Unlike processes which have separate memory spaces, threads within the same process share code, data, and heap while maintaining their own stack, registers, and program counter.",
        "keywords": ["shared address space", "own stack", "lightweight", "context switch cheaper", "IPC vs shared memory"],
    },
    {
        "id": 44,
        "topic": "Operating Systems",
        "question": "What are the benefits of multithreading?",
        "reference_answer": "Multithreading makes systems more responsive to user input, enables resource sharing through shared memory (faster than IPC), improves performance through parallelism on multi core systems, and is more economical than multi processing.",
        "keywords": ["responsiveness", "parallelism", "shared memory", "throughput", "synchronization overhead"],
    },
    {
        "id": 45,
        "topic": "Operating Systems",
        "question": "What is context switching and what is its overhead?",
        "reference_answer": "Context switching is the process of saving the state of a currently running process or thread (stored in PCB) and loading the saved state of the next process or thread to be executed. Overhead includes time to save/restore registers, program counter, memory pointers, and potential cache misses.",
        "keywords": ["save registers", "restore state", "scheduler", "cache misses", "context switch overhead"],
    },
    {
        "id": 46,
        "topic": "Operating Systems",
        "question": "What is the difference between preemptive and non preemptive scheduling?",
        "reference_answer": "Preemptive scheduling allows the OS to interrupt a running process and give CPU to another (context switching possible anytime). Non preemptive scheduling lets a process run until it voluntarily yields CPU (IO request) or terminates, reducing overhead but potentially causing starvation.",
        "keywords": ["timer interrupt", "preemption", "responsiveness", "context switch cost", "starvation risk"],
    },
    {
        "id": 47,
        "topic": "Operating Systems",
        "question": "Describe the CPU scheduling algorithms and their characteristics.",
        "reference_answer": "FCFS (First Come First Served): simple, non preemptive, causes convoy effect. SJN (Shortest Job Next): optimal average wait time but requires knowing burst time. Priority: may cause starvation. Round Robin: fair, causes more context switches. Multilevel Queue: complex but flexible scheduling.",
        "keywords": ["FCFS convoy", "SJF burst time", "priority starvation", "round robin quantum", "multilevel queue"],
    },
    {
        "id": 48,
        "topic": "Operating Systems",
        "question": "What is a deadlock and what are the four necessary conditions?",
        "reference_answer": "Deadlock is a situation where two or more processes are blocked forever, each waiting for the other to release resources. The four necessary conditions are: Mutual Exclusion (resource cannot be shared), Hold and Wait (holding resources while waiting for others), No Preemption (cannot forcefully take resources), and Circular Wait (cyclic dependency).",
        "keywords": ["mutual exclusion", "hold and wait", "no preemption", "circular wait", "resource allocation"],
    },
    {
        "id": 49,
        "topic": "Operating Systems",
        "question": "What are the methods to handle deadlocks?",
        "reference_answer": "Deadlock prevention (prevent one condition), deadlock avoidance (Banker's algorithm), deadlock detection and recovery (detect circular wait and recover), or simply ignore deadlocks (ostrich algorithm). Different systems use different strategies based on resource types and application requirements.",
        "keywords": ["prevention", "avoidance", "Banker's algorithm", "detection", "recovery/rollback"],
    },
    {
        "id": 50,
        "topic": "Operating Systems",
        "question": "What is inter process communication (IPC) and what are common mechanisms?",
        "reference_answer": "IPC is communication between processes allowing coordination and data exchange. Mechanisms include pipes (unidirectional data flow), named pipes (between unrelated processes), message queues (queue based), shared memory (fast but requires synchronization), semaphores (synchronization primitive), and sockets (network communication).",
        "keywords": ["pipes", "message queues", "shared memory", "semaphores", "sockets"],
    },
    {
        "id": 51,
        "topic": "Databases",
        "question": "What does SQL stand for and what is its primary purpose?",
        "reference_answer": "SQL stands for Structured Query Language. Its primary purpose is to manage and query relational databases, allowing users to create, read, update, and delete data using standardized commands (DDL, DML, DCL).",
        "keywords": ["query language", "relational tables", "CRUD", "SELECT", "schema"],
    },
    {
        "id": 52,
        "topic": "Databases",
        "question": "In relational databases, what is a primary key and what is its purpose?",
        "reference_answer": "A primary key is a column or set of columns that uniquely identifies each row in a table. Its purpose is to ensure data integrity by preventing duplicate records, providing a unique reference for establishing relationships between tables through foreign keys.",
        "keywords": ["unique identifier", "no duplicates", "entity integrity", "index", "foreign key reference"],
    },
    {
        "id": 53,
        "topic": "Databases",
        "question": "What is database normalization and what are the normal forms?",
        "reference_answer": "Database normalization is a process of organizing data into clear structures to minimize redundancy and prevent data anomalies. Normal forms include 1NF (atomic values), 2NF (no partial dependencies), 3NF (no transitive dependencies), and BCNF (every determinant is a candidate key).",
        "keywords": ["reduce redundancy", "update anomalies", "1NF atomic", "2NF partial dependency", "3NF transitive dependency"],
    },
    {
        "id": 54,
        "topic": "Databases",
        "question": "What is denormalization and when should you use it?",
        "reference_answer": "Denormalization is the process of intentionally introducing redundancy by combining tables to improve query performance. Use it in read heavy systems where query speed is critical, like dashboards or analytics, but be aware of maintenance overhead and potential data inconsistency risks.",
        "keywords": ["add redundancy", "faster reads", "fewer joins", "write complexity", "data warehouse"],
    },
    {
        "id": 55,
        "topic": "Databases",
        "question": "What is a foreign key and why is it important?",
        "reference_answer": "A foreign key is a column or set of columns that references the primary key of another table, establishing a relationship between tables. It's important for maintaining referential integrity, preventing orphaned records, and supporting complex queries through joins.",
        "keywords": ["references primary key", "table relationship", "referential integrity", "joins", "cascade rules"],
    },
    {
        "id": 56,
        "topic": "Databases",
        "question": "What is database indexing and how does it affect performance?",
        "reference_answer": "Database indexing creates a separate data structure (usually B tree or hash) that maps values to their row locations. Indexes dramatically improve read performance (faster searches), but slow down write operations (INSERT, UPDATE, DELETE) because the index must also be updated.",
        "keywords": ["B tree", "faster lookup", "logarithmic access", "write overhead", "selectivity"],
    },
    {
        "id": 57,
        "topic": "Databases",
        "question": "What is ACID and why is it important in databases?",
        "reference_answer": "ACID stands for Atomicity (all or nothing execution), Consistency (valid state transitions), Isolation (concurrent transactions don't interfere), and Durability (committed data persists even after failures). These properties ensure reliable, predictable database behavior and data integrity.",
        "keywords": ["atomicity", "consistency", "isolation", "durability", "transaction safety"],
    },
    {
        "id": 58,
        "topic": "Databases",
        "question": "What is the difference between SQL and NoSQL databases?",
        "reference_answer": "SQL databases use structured schemas with strong consistency (ACID), support complex queries through joins, and scale vertically. NoSQL databases have flexible/dynamic schemas, eventual consistency, scale horizontally, and are optimized for unstructured/semi structured data and high volume distributed systems.",
        "keywords": ["fixed schema", "joins", "horizontal scaling", "eventual consistency", "document/key value"],
    },
    {
        "id": 59,
        "topic": "Databases",
        "question": "What is a transaction and what are transaction properties?",
        "reference_answer": "A transaction is a sequence of database operations treated as a single atomic unit. It must satisfy ACID properties: execute completely or not at all, maintain valid state before and after, not interfere with other transactions, and persist after commit.",
        "keywords": ["all or nothing", "commit/rollback", "atomic", "ACID", "durability"],
    },
    {
        "id": 60,
        "topic": "Databases",
        "question": "What is a join and what are the types of joins in SQL?",
        "reference_answer": "A join combines rows from two or more tables based on related columns. Types include: INNER JOIN (only matching rows), LEFT JOIN (all from left table plus matches), RIGHT JOIN (all from right table plus matches), FULL OUTER JOIN (all rows from both), and CROSS JOIN (Cartesian product).",
        "keywords": ["inner join", "left join", "right join", "full outer", "ON condition"],
    },
    {
        "id": 61,
        "topic": "Software Engineering & Design Patterns",
        "question": "Describe the software development lifecycle (SDLC) and its phases.",
        "reference_answer": "The SDLC breaks development into: Requirements (determining expectations/needs), Design (architecture and algorithm planning), Development/Building (actual coding), Testing (ensuring correctness), Deployment (installation and availability), and Maintenance (updates and debugging).",
        "keywords": ["requirements", "design", "implementation", "testing", "deployment/maintenance"],
    },
    {
        "id": 62,
        "topic": "Software Engineering & Design Patterns",
        "question": "What is agile software development and what makes it different from waterfall?",
        "reference_answer": "Agile is an incremental, collaborative approach focused on continuously delivering work in small iterations with regular feedback rather than waiting for one large product release. Unlike waterfall (sequential phases), Agile allows teams to improve software as it's developed, enabling faster feedback and adaptation to changes.",
        "keywords": ["iterations", "sprints", "change adaptive", "waterfall sequential", "customer feedback"],
    },
    {
        "id": 63,
        "topic": "Software Engineering & Design Patterns",
        "question": "What is a design pattern and why are they important?",
        "reference_answer": "Design patterns are reusable solutions to common problems encountered in software design. They encapsulate best practices, provide a shared language for developers, speed up development by providing tested paradigms, and improve code maintainability, extensibility, and scalability.",
        "keywords": ["reusable solution", "common problem", "shared vocabulary", "maintainability", "extensibility"],
    },
    {
        "id": 64,
        "topic": "Software Engineering & Design Patterns",
        "question": "Explain the Singleton pattern and what are its use cases and drawbacks.",
        "reference_answer": "The Singleton pattern ensures that a class has only one instance and provides a global point of access to it. Use cases include loggers, database connections, and thread pools. Drawbacks include difficulty with unit testing, hidden dependencies, and violation of single responsibility principle.",
        "keywords": ["single instance", "global access", "lazy initialization", "testing difficulty", "logger/config"],
    },
    {
        "id": 65,
        "topic": "Software Engineering & Design Patterns",
        "question": "Explain the Factory pattern and how it differs from the Builder pattern.",
        "reference_answer": "Factory pattern creates objects without specifying exact classes, returning appropriate subtype. It's simpler but limited to single object creation. Builder pattern constructs complex objects step by step with optional parameters, better for objects with many attributes or complex construction logic.",
        "keywords": ["factory creates subtype", "creation encapsulation", "builder step by step", "complex object", "optional parameters"],
    },
    {
        "id": 66,
        "topic": "Software Engineering & Design Patterns",
        "question": "Explain the Observer pattern and provide a real world example.",
        "reference_answer": "Observer pattern defines one to many dependency where when one object (Subject) changes state, all dependents (Observers) are notified automatically. Real world example: event driven systems like button clicks notifying multiple listeners, or user action broadcasts in publish subscribe systems.",
        "keywords": ["publish subscribe", "subject", "observers", "notify on change", "event listeners"],
    },
    {
        "id": 67,
        "topic": "Software Engineering & Design Patterns",
        "question": "What are the three main OOP concepts and explain each briefly.",
        "reference_answer": "The three main concepts are: Encapsulation (bundling data and methods into a single unit with access control), Inheritance (extending classes to create new classes with shared functionality and is a relationships), and Polymorphism (objects taking multiple forms, allowing one interface to be used with different types).",
        "keywords": ["encapsulation", "inheritance", "polymorphism", "abstraction", "interface"],
    },
    {
        "id": 68,
        "topic": "Software Engineering & Design Patterns",
        "question": "What is the difference between method overriding and method overloading?",
        "reference_answer": "Method overloading occurs in the same class with the same method name but different parameters, resolved at compile time (static binding). Method overriding occurs in inherited classes where a subclass provides a specific implementation of a parent class method, resolved at runtime through dynamic binding.",
        "keywords": ["overloading parameters", "compile time", "overriding in subclass", "runtime dispatch", "same signature"],
    },
    {
        "id": 69,
        "topic": "Software Engineering & Design Patterns",
        "question": "What are access modifiers and what purposes do they serve?",
        "reference_answer": "Access modifiers control the visibility of class members: public (anywhere), private (only within the class), protected (within class and inherited classes), and package private/default (same package). They enforce encapsulation and control how classes interact.",
        "keywords": ["public", "private", "protected", "visibility control", "encapsulation"],
    },
    {
        "id": 70,
        "topic": "Software Engineering & Design Patterns",
        "question": "What is the difference between composition and inheritance?",
        "reference_answer": "Inheritance follows an is a relationship where a subclass IS A type of parent class. Composition follows a has a relationship where a class HAS A reference to another class as a member. Composition is often preferred for flexibility and avoiding rigid hierarchies and deep inheritance chains.",
        "keywords": ["has a", "is a", "delegation", "flexibility", "tight coupling tradeoff"],
    },
    {
        "id": 71,
        "topic": "Software Engineering & Design Patterns",
        "question": "What is the Model View Controller (MVC) pattern and how does it improve code organization?",
        "reference_answer": "MVC separates application into three components: Model (data and business logic), View (user interface), and Controller (handles input and coordinates model/view). This separation improves testability, allows multiple views of same data, enables parallel development, and makes code more maintainable.",
        "keywords": ["model data", "view UI", "controller input", "separation of concerns", "testability"],
    },
    {
        "id": 72,
        "topic": "Software Engineering & Design Patterns",
        "question": "What is the Repository pattern and what problem does it solve?",
        "reference_answer": "Repository pattern abstracts data access logic by providing a collection like interface for accessing data entities. It decouples business logic from data access, enables easy testing through mock repositories, and makes it easy to switch between different data sources (database, file, cache).",
        "keywords": ["data access abstraction", "decouple persistence", "collection interface", "mocking/testing", "swap data source"],
    },
    {
        "id": 73,
        "topic": "Software Engineering & Design Patterns",
        "question": "Explain the Strategy pattern with an example.",
        "reference_answer": "Strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable at runtime. Example: payment methods (CreditCard, PayPal, Bitcoin) as strategies with a common interface, allowing clients to choose the payment strategy without knowing details of each.",
        "keywords": ["algorithm family", "encapsulation", "interchangeable", "runtime selection", "payment method"],
    },
    {
        "id": 74,
        "topic": "Software Engineering & Design Patterns",
        "question": "What is the Adapter pattern and what problem does it solve?",
        "reference_answer": "Adapter pattern allows incompatible interfaces to work together by acting as a bridge between them. It solves problems when integrating legacy code with new systems, using third party libraries with different interfaces, or making incompatible systems interoperable.",
        "keywords": ["wrapper", "interface conversion", "incompatible APIs", "legacy integration", "client expectation"],
    },
    {
        "id": 75,
        "topic": "Networking & Web Technologies",
        "question": "What does HTTP stand for and what are HTTP status codes 200 and 404?",
        "reference_answer": "HTTP stands for Hypertext Transfer Protocol. Status code 200 indicates \"OK\" for a successful request. Status code 404 indicates \"Not Found\" when the requested resource cannot be located on the server.",
        "keywords": ["request response", "status code", "200 OK", "404 not found", "HTTP protocol"],
    },
    {
        "id": 76,
        "topic": "Networking & Web Technologies",
        "question": "What does TCP stand for and what is its role in networking?",
        "reference_answer": "TCP stands for Transmission Control Protocol. Its role is to establish reliable, ordered, error checked delivery of data over networks, ensuring that packets arrive in sequence and without corruption through acknowledgments and retransmission mechanisms.",
        "keywords": ["reliable delivery", "ordered bytes", "acknowledgments", "retransmission", "TCP protocol"],
    },
    {
        "id": 77,
        "topic": "Networking & Web Technologies",
        "question": "What does REST stand for and how does it differ from traditional RPC based APIs?",
        "reference_answer": "REST (Representational State Transfer) is an architectural style using standard HTTP methods (GET, POST, PUT, DELETE) on resources identified by URLs. Unlike RPC based APIs that call remote procedures, REST treats everything as resources with standard operations, making it more scalable and aligned with web standards.",
        "keywords": ["resources", "URLs", "HTTP verbs", "stateless", "representations"],
    },
    {
        "id": 78,
        "topic": "Networking & Web Technologies",
        "question": "What is the difference between GET and POST HTTP methods?",
        "reference_answer": "GET retrieves data from the server without body content, parameters in URL, cacheable, idempotent, and suitable for retrieving data. POST sends data to server with body content, parameters hidden, not cached, not idempotent, and suitable for creating or modifying resources.",
        "keywords": ["GET safe/idempotent", "POST not idempotent", "query params", "request body", "caching behavior"],
    },
    {
        "id": 79,
        "topic": "Networking & Web Technologies",
        "question": "What is API rate limiting and why is it important?",
        "reference_answer": "API rate limiting restricts the number of requests a client can make in a given time window to protect the API from abuse, ensure fair resource usage, and prevent denial of service attacks. It's important for system stability and preventing resource exhaustion.",
        "keywords": ["throttling", "requests per window", "429 too many", "prevent abuse", "protect resources"],
    },
    {
        "id": 80,
        "topic": "Networking & Web Technologies",
        "question": "What is the difference between authentication and authorization?",
        "reference_answer": "Authentication verifies the identity of a user (who are you), typically through credentials like username/password or tokens. Authorization determines what authenticated user is allowed to access (what can you do), typically through roles and permissions.",
        "keywords": ["authentication identity", "authorization permissions", "roles", "tokens", "access control"],
    },
    {
        "id": 81,
        "topic": "Networking & Web Technologies",
        "question": "What is CORS and what problem does it solve?",
        "reference_answer": "CORS (Cross Origin Resource Sharing) is a mechanism allowing restricted resources on a web page to be requested from another domain outside the domain from which the first resource was served. It solves the same origin policy restriction that would otherwise block such requests.",
        "keywords": ["same origin policy", "Access Control Allow Origin", "preflight OPTIONS", "browser enforcement", "cross site requests"],
    },
    {
        "id": 82,
        "topic": "Networking & Web Technologies",
        "question": "What is caching and what are common caching strategies?",
        "reference_answer": "Caching stores frequently accessed data in faster, temporary storage to reduce latency and database load. Common strategies include: LRU (Least Recently Used), LFU (Least Frequently Used), TTL based (time to live), write through, write back, and cache warming.",
        "keywords": ["cache hit/miss", "TTL expiry", "LRU eviction", "store responses", "write through/write back"],
    },
]
